{"ast":null,"code":"import { make, subscribe, onEnd, onPush, toPromise, take, share, filter, map, tap, merge, mergeMap, takeUntil, switchMap, fromValue, interval, makeSubject, onStart, scan, concat } from \"wonka\";\nimport { GraphQLError, parse, print, visit, Kind } from \"graphql\";\nimport { createContext, useContext, useState, useCallback, useMemo, useRef } from \"react\";\nimport { useSubjectValue } from \"react-wonka\";\n\nfunction _extends() {\n  return (_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nvar generateErrorMessage = function generateErrorMessage(networkErr, graphQlErrs) {\n  var error = \"\";\n\n  if (void 0 !== networkErr) {\n    return error = \"[Network] \" + networkErr.message;\n  }\n\n  if (void 0 !== graphQlErrs) {\n    graphQlErrs.forEach(function _ref(err) {\n      error += \"[GraphQL] \" + err.message + \"\\n\";\n    });\n  }\n\n  return error.trim();\n};\n\nvar rehydrateGraphQlError = function rehydrateGraphQlError(error) {\n  if (\"string\" == typeof error) {\n    return new GraphQLError(error);\n  } else if (\"object\" == typeof error && error.message) {\n    return new GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error.originalError, error.extensions || {});\n  } else {\n    return error;\n  }\n};\n\nfunction _toString() {\n  return this.message;\n}\n\nvar CombinedError = function (Error) {\n  function CombinedError(ref) {\n    var networkError = ref.networkError;\n    var response = ref.response;\n    var normalizedGraphQLErrors = (ref.graphQLErrors || []).map(rehydrateGraphQlError);\n    var message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n    Error.call(this, message);\n    this.name = \"CombinedError\";\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  if (Error) {\n    CombinedError.__proto__ = Error;\n  }\n\n  (CombinedError.prototype = Object.create(Error && Error.prototype)).constructor = CombinedError;\n  CombinedError.prototype.toString = _toString;\n  return CombinedError;\n}(Error);\n\nvar phash = function phash(h, x) {\n  h |= 0;\n\n  for (var i = 0, l = 0 | x.length; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\nvar seen = new Set();\n\nvar stringify = function stringify(x) {\n  if (void 0 === x) {\n    return \"\";\n  } else if (\"number\" == typeof x) {\n    return isFinite(x) ? \"\" + x : \"null\";\n  } else if (\"object\" != typeof x) {\n    return JSON.stringify(x);\n  } else if (null === x) {\n    return \"null\";\n  }\n\n  var out = \"\";\n\n  if (Array.isArray(x)) {\n    out = \"[\";\n\n    for (var i = 0, l = x.length; i < l; i++) {\n      if (i > 0) {\n        out += \",\";\n      }\n\n      var value = stringify(x[i]);\n      out += value.length > 0 ? value : \"null\";\n    }\n\n    return out += \"]\";\n  } else if (seen.has(x)) {\n    throw new TypeError(\"Converting circular structure to JSON\");\n  }\n\n  var keys = Object.keys(x).sort();\n  seen.add(x);\n  out = \"{\";\n\n  for (var i$1 = 0, l$1 = keys.length; i$1 < l$1; i$1++) {\n    var key = keys[i$1];\n    var value$1 = stringify(x[key]);\n\n    if (0 !== value$1.length) {\n      if (out.length > 1) {\n        out += \",\";\n      }\n\n      out += stringify(key) + \":\" + value$1;\n    }\n  }\n\n  seen.delete(x);\n  return out += \"}\";\n};\n\nvar stringifyVariables = function stringifyVariables(x) {\n  seen.clear();\n  return stringify(x);\n};\n\nvar hashQuery = function hashQuery(q) {\n  return x = q.replace(/[\\s,]+/g, \" \").trim(), phash(5381, x) >>> 0;\n  var x;\n};\n\nvar docs = Object.create(null);\n\nvar createRequest = function createRequest(q, vars) {\n  var key;\n  var query;\n\n  if (\"string\" == typeof q) {\n    key = hashQuery(q);\n    query = void 0 !== docs[key] ? docs[key] : parse(q);\n  } else if (void 0 !== q.__key) {\n    key = q.__key;\n    query = q;\n  } else {\n    key = hashQuery(print(q));\n    query = void 0 !== docs[key] ? docs[key] : q;\n  }\n\n  docs[key] = query;\n  query.__key = key;\n  return {\n    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,\n    query: query,\n    variables: vars || {}\n  };\n};\n\nvar addMetadata = function addMetadata(source, meta) {\n  return _extends(_extends({}, source), {\n    context: _extends(_extends({}, source.context), {\n      meta: _extends(_extends({}, source.context.meta), meta)\n    })\n  });\n};\n\nvar makeResult = function makeResult(operation, result, response) {\n  return {\n    operation: operation,\n    data: result.data,\n    error: Array.isArray(result.errors) ? new CombinedError({\n      graphQLErrors: result.errors,\n      response: response\n    }) : void 0,\n    extensions: \"object\" == typeof result.extensions && null !== result.extensions ? result.extensions : void 0\n  };\n};\n\nvar makeErrorResult = function makeErrorResult(operation, error, response) {\n  return {\n    operation: operation,\n    data: void 0,\n    error: new CombinedError({\n      networkError: error,\n      response: response\n    }),\n    extensions: void 0\n  };\n};\n\nvar collectTypes = function collectTypes(obj, types) {\n  if (void 0 === types) {\n    types = [];\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function _ref(inner) {\n      collectTypes(inner, types);\n    });\n  } else if (\"object\" == typeof obj && null !== obj) {\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var val = obj[key];\n\n        if (\"__typename\" === key && \"string\" == typeof val) {\n          types.push(val);\n        } else if (\"object\" == typeof val && null !== val) {\n          collectTypes(val, types);\n        }\n      }\n    }\n  }\n\n  return types;\n};\n\nfunction _ref2(v, i, a) {\n  return a.indexOf(v) === i;\n}\n\nvar collectTypesFromResponse = function collectTypesFromResponse(response) {\n  return collectTypes(response).filter(_ref2);\n};\n\nfunction _ref3(s) {\n  return \"Field\" === s.kind && \"__typename\" === s.name.value;\n}\n\nvar formatNode = function formatNode(n) {\n  if (void 0 === n.selectionSet) {\n    return !1;\n  }\n\n  if (n.selectionSet.selections.some(_ref3)) {\n    return n;\n  }\n\n  return _extends(_extends({}, n), {\n    selectionSet: _extends(_extends({}, n.selectionSet), {\n      selections: n.selectionSet.selections.concat([{\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: \"__typename\"\n        }\n      }])\n    })\n  });\n};\n\nvar formatDocument = function formatDocument(astNode) {\n  return visit(astNode, {\n    Field: formatNode,\n    InlineFragment: formatNode\n  });\n};\n\nfunction withPromise(source$) {\n  source$.toPromise = function () {\n    return toPromise(take(1)(source$));\n  };\n\n  return source$;\n}\n\nvar shouldSkip = function shouldSkip(ref) {\n  var operationName = ref.operationName;\n  return \"subscription\" !== operationName && \"query\" !== operationName;\n};\n\nfunction _ref(x) {\n  return \"\" + x;\n}\n\nvar serializeResult = function serializeResult(ref) {\n  var error = ref.error;\n  var result = {\n    data: ref.data,\n    error: void 0\n  };\n\n  if (void 0 !== error) {\n    result.error = {\n      networkError: \"\" + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(_ref)\n    };\n  }\n\n  return result;\n};\n\nvar deserializeResult = function deserializeResult(operation, result) {\n  var error = result.error;\n  var deserialized = {\n    operation: operation,\n    data: result.data,\n    extensions: void 0,\n    error: void 0\n  };\n\n  if (void 0 !== error) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors\n    });\n  }\n\n  return deserialized;\n};\n\nvar ssrExchange = function ssrExchange(params) {\n  var data = {};\n\n  var isCached = function isCached(operation) {\n    return !shouldSkip(operation) && void 0 !== data[operation.key];\n  };\n\n  function _ref2(op) {\n    return !isCached(op);\n  }\n\n  function _ref3(op) {\n    return deserializeResult(op, data[op.key]);\n  }\n\n  function _ref4(op) {\n    return isCached(op);\n  }\n\n  function _ref5(result) {\n    var operation = result.operation;\n\n    if (!shouldSkip(operation)) {\n      var serialized = serializeResult(result);\n      data[operation.key] = serialized;\n    }\n  }\n\n  function _ref6(result) {\n    delete data[result.operation.key];\n  }\n\n  var ssr = function ssr(ref) {\n    var client = ref.client;\n    var forward = ref.forward;\n    return function (ops$) {\n      var isClient = params && \"boolean\" == typeof params.isClient ? !!params.isClient : !client.suspense;\n      var sharedOps$ = share(ops$);\n      var forwardedOps$ = forward(filter(_ref2)(sharedOps$));\n      var cachedOps$ = map(_ref3)(filter(_ref4)(sharedOps$));\n\n      if (!isClient) {\n        forwardedOps$ = tap(_ref5)(forwardedOps$);\n      } else {\n        cachedOps$ = tap(_ref6)(cachedOps$);\n      }\n\n      return merge([forwardedOps$, cachedOps$]);\n    };\n  };\n\n  ssr.restoreData = function (restore) {\n    return _extends(data, restore);\n  };\n\n  ssr.extractData = function () {\n    return _extends({}, data);\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n\nvar shouldSkip$1 = function shouldSkip$1(ref) {\n  var operationName = ref.operationName;\n  return \"mutation\" !== operationName && \"query\" !== operationName;\n};\n\nfunction _ref$1(operation) {\n  return _extends(_extends({}, operation), {\n    query: formatDocument(operation.query)\n  });\n}\n\nfunction _ref5(op) {\n  return addMetadata(op, {\n    cacheOutcome: \"miss\"\n  });\n}\n\nfunction _ref7(op) {\n  return shouldSkip$1(op);\n}\n\nvar cacheExchange = function cacheExchange(ref) {\n  var forward = ref.forward;\n  var client = ref.client;\n  var resultCache = new Map();\n  var operationCache = Object.create(null);\n  var mapTypeNames = _ref$1;\n  var handleAfterMutation = afterMutation(resultCache, operationCache, client);\n  var handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  var isOperationCached = function isOperationCached(operation) {\n    var requestPolicy = operation.context.requestPolicy;\n    return \"query\" === operation.operationName && \"network-only\" !== requestPolicy && (\"cache-only\" === requestPolicy || resultCache.has(operation.key));\n  };\n\n  function _ref2(operation) {\n    var cachedResult = resultCache.get(operation.key);\n\n    var result = _extends(_extends({}, cachedResult), {\n      operation: addMetadata(operation, {\n        cacheOutcome: cachedResult ? \"hit\" : \"miss\"\n      })\n    });\n\n    if (\"cache-and-network\" === operation.context.requestPolicy) {\n      result.stale = !0;\n      reexecuteOperation(client, operation);\n    }\n\n    return result;\n  }\n\n  function _ref3(op) {\n    return !shouldSkip$1(op) && isOperationCached(op);\n  }\n\n  function _ref4(response) {\n    if (response.operation && \"mutation\" === response.operation.operationName) {\n      handleAfterMutation(response);\n    } else if (response.operation && \"query\" === response.operation.operationName) {\n      handleAfterQuery(response);\n    }\n  }\n\n  function _ref6(op) {\n    return !shouldSkip$1(op) && !isOperationCached(op);\n  }\n\n  return function (ops$) {\n    var sharedOps$ = share(ops$);\n    var cachedOps$ = map(_ref2)(filter(_ref3)(sharedOps$));\n    var forwardedOps$ = tap(_ref4)(forward(map(_ref5)(merge([map(mapTypeNames)(filter(_ref6)(sharedOps$)), filter(_ref7)(sharedOps$)]))));\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\nvar reexecuteOperation = function reexecuteOperation(client, operation) {\n  return client.reexecuteOperation(_extends(_extends({}, operation), {\n    context: _extends(_extends({}, operation.context), {\n      requestPolicy: \"network-only\"\n    })\n  }));\n};\n\nvar afterMutation = function afterMutation(resultCache, operationCache, client) {\n  function _ref9(key) {\n    if (resultCache.has(key)) {\n      var operation = resultCache.get(key).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  }\n\n  return function (response) {\n    var pendingOperations = new Set();\n\n    function _ref8(key) {\n      pendingOperations.add(key);\n    }\n\n    collectTypesFromResponse(response.data).forEach(function (typeName) {\n      var operations = operationCache[typeName] || (operationCache[typeName] = new Set());\n      operations.forEach(_ref8);\n      operations.clear();\n    });\n    pendingOperations.forEach(_ref9);\n  };\n};\n\nvar afterQuery = function afterQuery(resultCache, operationCache) {\n  return function (response) {\n    var operation = response.operation;\n    var data = response.data;\n\n    if (null == data) {\n      return;\n    }\n\n    resultCache.set(operation.key, {\n      operation: operation,\n      data: data,\n      error: response.error\n    });\n    collectTypesFromResponse(response.data).forEach(function (typeName) {\n      (operationCache[typeName] || (operationCache[typeName] = new Set())).add(operation.key);\n    });\n  };\n};\n\nvar isSubscriptionOperation = function isSubscriptionOperation(operation) {\n  return \"subscription\" === operation.operationName;\n};\n\nfunction _ref$2(op) {\n  return !isSubscriptionOperation(op);\n}\n\nvar subscriptionExchange = function subscriptionExchange(ref) {\n  var forwardSubscription = ref.forwardSubscription;\n  return function (ref) {\n    var client = ref.client;\n    var forward = ref.forward;\n    return function (ops$) {\n      var sharedOps$ = share(ops$);\n      var subscriptionResults$ = mergeMap(function (operation) {\n        var key = operation.key;\n        var teardown$ = filter(function (op) {\n          return \"teardown\" === op.operationName && op.key === key;\n        })(sharedOps$);\n        return takeUntil(teardown$)(function (operation) {\n          var observableish = forwardSubscription({\n            key: operation.key.toString(36),\n            query: print(operation.query),\n            variables: operation.variables,\n            context: _extends({}, operation.context)\n          });\n          return make(function (ref) {\n            var _next = ref[0];\n            var _complete = ref[1];\n            var isComplete = !1;\n            var sub = observableish.subscribe({\n              next: function next(result) {\n                return _next(makeResult(operation, result));\n              },\n              error: function error(err) {\n                return _next(makeErrorResult(operation, err));\n              },\n              complete: function complete() {\n                if (!isComplete) {\n                  client.reexecuteOperation(_extends(_extends({}, operation), {\n                    operationName: \"teardown\"\n                  }));\n                }\n\n                _complete();\n              }\n            });\n            return function () {\n              isComplete = !0;\n              sub.unsubscribe();\n            };\n          });\n        }(operation));\n      })(filter(isSubscriptionOperation)(sharedOps$));\n      var forward$ = forward(filter(_ref$2)(sharedOps$));\n      return merge([subscriptionResults$, forward$]);\n    };\n  };\n};\n\nfunction _ref2$1(result) {\n  return console.log(\"[Exchange debug]: Completed operation: \", result);\n}\n\nfunction _ref3$1(op) {\n  return console.log(\"[Exchange debug]: Incoming operation: \", op);\n}\n\nvar debugExchange = function debugExchange(ref) {\n  var forward = ref.forward;\n\n  if (\"production\" === process.env.NODE_ENV) {\n    return function _ref(ops$) {\n      return forward(ops$);\n    };\n  } else {\n    return function _ref4(ops$) {\n      return tap(_ref2$1)(forward(tap(_ref3$1)(ops$)));\n    };\n  }\n};\n\nvar dedupExchange = function dedupExchange(ref) {\n  var forward = ref.forward;\n  var inFlightKeys = new Set();\n\n  var filterIncomingOperation = function filterIncomingOperation(operation) {\n    var key = operation.key;\n    var operationName = operation.operationName;\n\n    if (\"teardown\" === operationName) {\n      inFlightKeys.delete(key);\n      return !0;\n    } else if (\"query\" !== operationName) {\n      return !0;\n    }\n\n    var isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  var afterOperationResult = function afterOperationResult(ref) {\n    inFlightKeys.delete(ref.operation.key);\n  };\n\n  return function (ops$) {\n    var forward$ = filter(filterIncomingOperation)(ops$);\n    return tap(afterOperationResult)(forward(forward$));\n  };\n};\n\nfunction _ref$3(operation) {\n  var operationName = operation.operationName;\n  return \"query\" === operationName || \"mutation\" === operationName;\n}\n\nvar fetchExchange = function fetchExchange(ref) {\n  var forward = ref.forward;\n  var isOperationFetchable = _ref$3;\n\n  function _ref2(op) {\n    return !isOperationFetchable(op);\n  }\n\n  return function (ops$) {\n    var sharedOps$ = share(ops$);\n    var fetchResults$ = mergeMap(function (operation) {\n      var key = operation.key;\n      var teardown$ = filter(function (op) {\n        return \"teardown\" === op.operationName && op.key === key;\n      })(sharedOps$);\n      return takeUntil(teardown$)(createFetchSource(operation));\n    })(filter(isOperationFetchable)(sharedOps$));\n    var forward$ = forward(filter(_ref2)(sharedOps$));\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nfunction _ref3$2(node) {\n  return node.kind === Kind.OPERATION_DEFINITION && node.name;\n}\n\nvar createFetchSource = function createFetchSource(operation) {\n  if (\"production\" !== process.env.NODE_ENV && \"subscription\" === operation.operationName) {\n    throw new Error(\"Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?\");\n  }\n\n  return make(function (ref) {\n    var next = ref[0];\n    var complete = ref[1];\n    var abortController = \"undefined\" != typeof AbortController ? new AbortController() : void 0;\n    var context = operation.context;\n    var extraOptions = \"function\" == typeof context.fetchOptions ? context.fetchOptions() : context.fetchOptions || {};\n    var operationName = void 0 !== (node = operation.query.definitions.find(_ref3$2)) && node.name ? node.name.value : null;\n    var node;\n    var body = {\n      query: print(operation.query),\n      variables: operation.variables\n    };\n\n    if (null !== operationName) {\n      body.operationName = operationName;\n    }\n\n    var fetchOptions = _extends(_extends({\n      body: JSON.stringify(body),\n      method: \"POST\"\n    }, extraOptions), {\n      headers: _extends({\n        \"content-type\": \"application/json\"\n      }, extraOptions.headers),\n      signal: void 0 !== abortController ? abortController.signal : void 0\n    });\n\n    executeFetch(operation, fetchOptions).then(function (result) {\n      if (void 0 !== result) {\n        next(result);\n      }\n\n      complete();\n    });\n    return function () {\n      if (void 0 !== abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nvar executeFetch = function executeFetch(operation, opts) {\n  var ref = operation.context;\n  var response;\n  return (ref.fetch || fetch)(ref.url, opts).then(function (res) {\n    var status = res.status;\n    response = res;\n\n    if (status < 200 || status >= (\"manual\" === opts.redirect ? 400 : 300)) {\n      throw new Error(res.statusText);\n    } else {\n      return res.json();\n    }\n  }).then(function (result) {\n    return makeResult(operation, result, response);\n  }).catch(function (err) {\n    if (\"AbortError\" !== err.name) {\n      return makeErrorResult(operation, err, response);\n    }\n  });\n};\n\nfunction _ref$4() {\n  return !1;\n}\n\nfunction _ref2$2(ref) {\n  var operationName = ref.operationName;\n\n  if (\"teardown\" !== operationName && \"production\" !== process.env.NODE_ENV) {\n    console.warn('No exchange has handled operations of type \"' + operationName + \"\\\". Check whether you've added an exchange responsible for these operations.\");\n  }\n}\n\nvar fallbackExchangeIO = function fallbackExchangeIO(ops$) {\n  return filter(_ref$4)(tap(_ref2$2)(ops$));\n};\n\nvar composeExchanges = function composeExchanges(exchanges) {\n  if (1 === exchanges.length) {\n    return exchanges[0];\n  }\n\n  return function (ref) {\n    var client = ref.client;\n    return exchanges.reduceRight(function (forward, exchange) {\n      return exchange({\n        client: client,\n        forward: forward\n      });\n    }, ref.forward);\n  };\n};\n\nvar defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n\nvar createClient = function createClient(opts) {\n  return new Client(opts);\n};\n\nvar Client = function Client(opts) {\n  var this$1 = this;\n  this.activeOperations = Object.create(null);\n\n  this.createOperationContext = function (opts) {\n    var requestPolicy = (opts || {}).requestPolicy;\n\n    if (void 0 === requestPolicy) {\n      requestPolicy = this$1.requestPolicy;\n    }\n\n    return _extends(_extends({\n      url: this$1.url,\n      fetchOptions: this$1.fetchOptions,\n      fetch: this$1.fetch\n    }, opts), {\n      requestPolicy: requestPolicy\n    });\n  };\n\n  this.createRequestOperation = function (type, ref, opts) {\n    return {\n      key: ref.key,\n      query: ref.query,\n      variables: ref.variables,\n      operationName: type,\n      context: this$1.createOperationContext(opts)\n    };\n  };\n\n  this.reexecuteOperation = function (operation) {\n    if ((this$1.activeOperations[operation.key] || 0) > 0) {\n      this$1.dispatchOperation(operation);\n    }\n  };\n\n  this.executeQuery = function (query, opts) {\n    var operation = this$1.createRequestOperation(\"query\", query, opts);\n    var response$ = this$1.executeRequestOperation(operation);\n    var pollInterval = operation.context.pollInterval;\n\n    if (pollInterval) {\n      return switchMap(function _ref() {\n        return response$;\n      })(merge([fromValue(0), interval(pollInterval)]));\n    }\n\n    return response$;\n  };\n\n  this.executeSubscription = function (query, opts) {\n    var operation = this$1.createRequestOperation(\"subscription\", query, opts);\n    return this$1.executeRequestOperation(operation);\n  };\n\n  this.executeMutation = function (query, opts) {\n    var operation = this$1.createRequestOperation(\"mutation\", query, opts);\n    return this$1.executeRequestOperation(operation);\n  };\n\n  this.url = opts.url;\n  this.fetchOptions = opts.fetchOptions;\n  this.fetch = opts.fetch;\n  this.suspense = !!opts.suspense;\n  this.requestPolicy = opts.requestPolicy || \"cache-first\";\n  var ref = makeSubject();\n  var nextOperation = ref[1];\n  this.operations$ = ref[0];\n  var queuedOperations = [];\n  var isDispatching = !1;\n\n  this.dispatchOperation = function (operation) {\n    queuedOperations.push(operation);\n\n    if (!isDispatching) {\n      isDispatching = !0;\n      var queued;\n\n      while (void 0 !== (queued = queuedOperations.shift())) {\n        nextOperation(queued);\n      }\n\n      isDispatching = !1;\n    }\n  };\n\n  this.exchange = composeExchanges(void 0 !== opts.exchanges ? opts.exchanges : defaultExchanges);\n  this.results$ = share(this.exchange({\n    client: this,\n    forward: fallbackExchangeIO\n  })(this.operations$));\n};\n\nClient.prototype.onOperationStart = function onOperationStart(operation) {\n  var key = operation.key;\n  this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n  this.dispatchOperation(operation);\n};\n\nClient.prototype.onOperationEnd = function onOperationEnd(operation) {\n  var key = operation.key;\n  var prevActive = this.activeOperations[key] || 0;\n\n  if ((this.activeOperations[key] = prevActive <= 0 ? 0 : prevActive - 1) <= 0) {\n    this.dispatchOperation(_extends(_extends({}, operation), {\n      operationName: \"teardown\"\n    }));\n  }\n};\n\nClient.prototype.executeRequestOperation = function executeRequestOperation(operation) {\n  var this$1 = this;\n  var key = operation.key;\n  var operationName = operation.operationName;\n  var operationResults$ = filter(function (res) {\n    return res.operation.key === key;\n  })(this.results$);\n\n  if (\"mutation\" === operationName) {\n    return take(1)(onStart(function _ref2() {\n      return this$1.dispatchOperation(operation);\n    })(operationResults$));\n  }\n\n  var teardown$ = filter(function (op) {\n    return \"teardown\" === op.operationName && op.key === key;\n  })(this.operations$);\n  var result$ = onEnd(function () {\n    return this$1.onOperationEnd(operation);\n  })(onStart(function () {\n    return this$1.onOperationStart(operation);\n  })(takeUntil(teardown$)(operationResults$)));\n  return !1 !== operation.context.suspense && this.suspense && \"query\" === operationName ? (source = result$, make(function (ref) {\n    var push = ref[0];\n    var end = ref[1];\n    var isCancelled = !1;\n    var resolveSuspense;\n    var synchronousResult;\n    var teardown = subscribe(function (value) {\n      if (void 0 === resolveSuspense) {\n        synchronousResult = value;\n      } else if (!isCancelled) {\n        resolveSuspense(value);\n        end();\n        teardown();\n      }\n    })(onEnd(end)(onPush(push)(source)))[0];\n\n    if (void 0 === synchronousResult) {\n      throw new Promise(function _ref(resolve) {\n        resolveSuspense = resolve;\n      });\n    }\n\n    return function () {\n      isCancelled = !0;\n      teardown();\n    };\n  })) : result$;\n  var source;\n};\n\nClient.prototype.query = function query(query$1, variables, context) {\n  if (!context || \"boolean\" != typeof context.suspense) {\n    context = _extends(_extends({}, context), {\n      suspense: !1\n    });\n  }\n\n  return withPromise(this.executeQuery(createRequest(query$1, variables), context));\n};\n\nClient.prototype.mutation = function mutation(query, variables, context) {\n  return withPromise(this.executeMutation(createRequest(query, variables), context));\n};\n\nvar defaultClient = createClient({\n  url: \"/graphql\"\n});\nvar Context = createContext(defaultClient);\nvar Provider = Context.Provider;\nvar Consumer = Context.Consumer;\nvar hasWarnedAboutDefault = !1;\n\nvar useClient = function useClient() {\n  var client = useContext(Context);\n\n  if (\"production\" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {\n    hasWarnedAboutDefault = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n\n  return client;\n};\n\nvar useMutation = function useMutation(query) {\n  var client = useClient();\n  var ref = useState({\n    fetching: !1,\n    stale: !1,\n    error: void 0,\n    data: void 0,\n    extensions: void 0\n  });\n  var setState = ref[1];\n\n  function _ref(result) {\n    setState({\n      fetching: !1,\n      stale: !!result.stale,\n      data: result.data,\n      error: result.error,\n      extensions: result.extensions\n    });\n    return result;\n  }\n\n  return [ref[0], useCallback(function (variables, context) {\n    setState({\n      fetching: !0,\n      stale: !1,\n      error: void 0,\n      data: void 0,\n      extensions: void 0\n    });\n    var request = createRequest(query, variables);\n    return toPromise(client.executeMutation(request, context || {})).then(_ref);\n  }, [client, query, setState])];\n};\n\nvar useRequest = function useRequest(query, variables) {\n  var prev = useRef(void 0);\n  return useMemo(function () {\n    var request = createRequest(query, variables);\n\n    if (void 0 !== prev.current && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n\nvar initialState = {\n  fetching: !1,\n  stale: !1,\n  data: void 0,\n  error: void 0,\n  extensions: void 0\n};\n\nfunction _ref2$3(result, partial) {\n  return _extends(_extends(_extends({}, result), {\n    stale: !1\n  }), partial);\n}\n\nfunction _ref3$3(ref) {\n  return {\n    fetching: !1,\n    stale: !!ref.stale,\n    data: ref.data,\n    error: ref.error,\n    extensions: ref.extensions\n  };\n}\n\nfunction _ref4(query$) {\n  if (!query$) {\n    return fromValue({\n      fetching: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0\n  }), map(_ref3$3)(query$), fromValue({\n    fetching: !1\n  })]);\n}\n\nfunction _ref5$1(query$$) {\n  return scan(_ref2$3, initialState)(switchMap(_ref4)(query$$));\n}\n\nvar useQuery = function useQuery(args) {\n  var client = useClient();\n  var request = useRequest(args.query, args.variables);\n\n  function _ref(opts) {\n    return client.executeQuery(request, _extends(_extends({\n      requestPolicy: args.requestPolicy,\n      pollInterval: args.pollInterval\n    }, args.context), opts));\n  }\n\n  var makeQuery$ = useMemo(function () {\n    return _ref;\n  }, [client, request, args.requestPolicy, args.pollInterval, args.context]);\n  var ref = useSubjectValue(_ref5$1, useMemo(function () {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]), initialState);\n  var update = ref[1];\n  return [ref[0], useCallback(function (opts) {\n    return update(makeQuery$(opts));\n  }, [update, makeQuery$])];\n};\n\nvar initialState$1 = {\n  fetching: !1,\n  stale: !1,\n  data: void 0,\n  error: void 0,\n  extensions: void 0\n};\n\nfunction _ref3$4(ref) {\n  return {\n    fetching: !0,\n    stale: !!ref.stale,\n    data: ref.data,\n    error: ref.error,\n    extensions: ref.extensions\n  };\n}\n\nfunction _ref4$1(subscription$) {\n  if (!subscription$) {\n    return fromValue({\n      fetching: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0\n  }), map(_ref3$4)(subscription$), fromValue({\n    fetching: !1\n  })]);\n}\n\nvar useSubscription = function useSubscription(args, handler) {\n  var client = useClient();\n  var handlerRef = useRef(handler);\n  handlerRef.current = handler;\n  var request = useRequest(args.query, args.variables);\n\n  function _ref(opts) {\n    return client.executeSubscription(request, _extends(_extends({}, args.context), opts));\n  }\n\n  var makeSubscription$ = useMemo(function () {\n    return _ref;\n  }, [client, request, args.context]);\n\n  function _ref2(result, partial) {\n    var handler = handlerRef.current;\n    var data = void 0 !== partial.data ? \"function\" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;\n    return _extends(_extends(_extends(_extends({}, result), {\n      stale: !1\n    }), partial), {\n      data: data\n    });\n  }\n\n  var ref = useSubjectValue(function (subscription$$) {\n    return scan(_ref2, initialState$1)(switchMap(_ref4$1)(subscription$$));\n  }, useMemo(function () {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]), initialState$1);\n  var update = ref[1];\n  return [ref[0], useCallback(function (opts) {\n    return update(makeSubscription$(opts));\n  }, [update, makeSubscription$])];\n};\n\nfunction Mutation(ref) {\n  var children = ref.children;\n  var ref$1 = useMutation(ref.query);\n  var executeMutation = ref$1[1];\n  return children(_extends(_extends({}, ref$1[0]), {\n    executeMutation: executeMutation\n  }));\n}\n\nfunction Query(props) {\n  var ref = useQuery(props);\n  var executeQuery = ref[1];\n  return props.children(_extends(_extends({}, ref[0]), {\n    executeQuery: executeQuery\n  }));\n}\n\nfunction Subscription(props) {\n  var ref = useSubscription(props, props.handler);\n  var executeSubscription = ref[1];\n  return props.children(_extends(_extends({}, ref[0]), {\n    executeSubscription: executeSubscription\n  }));\n}\n\nexport { Client, CombinedError, Consumer, Context, Mutation, Provider, Query, Subscription, cacheExchange, composeExchanges, createClient, createRequest, debugExchange, dedupExchange, defaultExchanges, fallbackExchangeIO, fetchExchange, formatDocument, makeErrorResult, makeResult, ssrExchange, stringifyVariables, subscriptionExchange, useClient, useMutation, useQuery, useSubscription };","map":null,"metadata":{},"sourceType":"module"}